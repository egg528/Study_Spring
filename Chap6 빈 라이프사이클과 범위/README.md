# 5. 빈 라이프사이클과 범위

``` java
public class Main {
	public static void main(String[] args) throws IOException {
		
		// 컨테이너 초기화
		AnnotationConfigApplicationContext ctx = 
				new AnnotationConfigApplicationContext(AppCtx.class);
			
                // 컨테이너에서 빈 객체 찾아 사용하기
		Client client = ctx.getBean(Client.class);
		
                // 컨테이너 종료
		ctx.close();
	}
}
```
- 스프링 컨테이너는 위 코드와 같이 초기화와 종료라는 라이프 사이클을 가진다.
- 컨테이너 초기화 작업은 다음의 작업을 포함한다.
  - 빈 객체 생성, 의존 주입, 초기화
- 컨테이너 종료 작업은 다음의 작업을 포함한다.
  - 빈 객체의 소멸

## `스프링 빈 객체의 라이프 사이클`
- 스프링 빈 객체는 생성 -> 의존 주입 -> 초기화 -> 소멸의 라이프 사이클을 가지게 되고 스프링 컨테이너에 의해 관리된다.  
   
### `빈 객체 생성과 초기화는 무엇이 다를까?`
- 일반적으로 객체 초기화는 생성자로 진행된다. 때문에 객체 생성과 초기화가 따로 있는 부분에서 의문이 생겼다.
  - 또한 의존 주입 단계에서 객체 필드에 대해서도 초기화가 완료되지 않는가?
    - 일반적으로 생성자를 통해 객체를 생성함과 동시에 초기화를 진행하기에 둘을 구분하여 생각하지 않았다.
    - 하지만 둘은 다른 영역이다.
    - ``` java
      public class Main {
          public static void main(String[] args) throws IOException {
                // 객체 생성
              Man man = new Man();
      
              // 객체 초기화;
              man.age = 27;
          }
          public class Man{
              int age;
          }
      }
      ```
    - 위 코드와 같이 객체 생성과 값을 등록하는 초기화는 다른 작업이다.   
    
  
- 객체 생성과 초기화가 달라도 의존 주입을 통해 필드 값 혹은 또 다른 객체가 주입되지 않는가?
  - 생성, 의존 주입 후에도 초기화되지 않은 필드가 이때 초기화 된다.


### `초기화를 생성/의존 주입과 분리해야하는 이유는?`
- 예시에서는 DB 커넥션 풀, 채팅 클라이언트와 같은 작업의 경우를 꼽는다.
  - 왜?????

   
## `빈 객체 초기화 방법`
1. InitializingBean, DisposableBean 인터페이스 사용하기
   - 전자의 경우 객체 생성 뒤 필요한 초기화 과정을 정의하는 메서드를 작성한다.
   - 후자의 경우 소멸 전 필요한 작업을 메서드에 작성한다.
   - 스프링 전용 인터페이스다. 코드가 자바가 아닌 스프링에 의존하게 된다.
   - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
   - 외부 라이브러리를 사용할 때, 그 라이브러리의 초기화와 소멸 콜백 메서드를 제공할 방법이 없다. (외부 라이브러리에 이 인터페이스를 구현할 수 없다.)

2. @Bean 어노테이션 initMethod, destoryMethod 설정하기
   - 위 값으로 메서드 이름을 등록하면 1번과 같은 방식으로 동작한다.
   - 메서드 이름 자유롭게 사용 가능
   - 스프링 빈이 스프링 코드를 의존하지 않는다.
   - 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.
   - 기본적으로 @Bean 어노테이션에는 destoryMethod로 INFER_METHOD가 등록되어 있어 close, shutdown으로 메서드를 만들면 추가적인 등록 없이 destoyMethod로 사용할 수 있다.
   - initMethod는 설정 필요
3. @PostConstruct, @PreDestory
   - 메서드에 위 어노테이션을 붙여 생성 후, 소멸 전 로직으로 사용할 수 있다.
   - 스프링에서도 권장하는 방식이며 스프링에 종속적이지 않다.
   - 단, 외부 라이브러리에 적용할 수 없다는 단점이 있다.

`외부 라이브러리의 경우 @Bean 어노테이션에 값을 설정하여 사용하고, 그 이외 작업에는 @PostConstruct @PreDsetory를 사용하자!`

## `빈 객체 생성과 관리 범위`
- 스프링 컨테이너는 기본적으로 Bean 객체를 하나만 생성하여 관리한다. 즉, 싱글톤 방식을 기본을 한다.
- 단, @Scope을 통해 Bean 객체의 생성과 관리 범위를 변경할 수 있다.
  - Singleton: 하나의 객체만으로 관리. 스프링 기본 Scope.
  - Protype: 매번 새로운 객체를 생성하여 반환
    - Protype 범위를 갖는 빈의 경우 컨테이너에서 소멸 작업을 처리해주지 않는다는 점을 주의해야 한다.
